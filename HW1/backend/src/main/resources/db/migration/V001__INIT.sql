-- Enums
CREATE TYPE user_role AS ENUM ('USER', 'STAFF');

-- Tables
CREATE TABLE restaurant
(
    id   BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    name VARCHAR(255) UNIQUE NOT NULL,
    seats INT NOT NULL,
    district VARCHAR(255) NOT NULL,

    CONSTRAINT pk_restaurant PRIMARY KEY (id)
);

CREATE TABLE "user"
(
    id       BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    username VARCHAR(255) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    role     user_role NOT NULL DEFAULT 'USER',
    CONSTRAINT pk_user PRIMARY KEY (id)
);

CREATE TABLE meal
(
    id            BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    restaurant_id BIGINT NOT NULL,
    price         NUMERIC(10,2) NOT NULL,
    date          TIMESTAMP NOT NULL,
    meal          VARCHAR(255) NOT NULL,

    CONSTRAINT pk_meal PRIMARY KEY (id),
    CONSTRAINT fk_meal_on_restaurant FOREIGN KEY (restaurant_id)
        REFERENCES restaurant (id) ON DELETE CASCADE,
    CONSTRAINT unique_meal_per_day UNIQUE (restaurant_id, meal, date)
);

CREATE TABLE user_meal
(
    id      BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    user_id BIGINT NOT NULL,
    meal_id BIGINT NOT NULL,
    is_check   BOOLEAN DEFAULT FALSE NOT NULL,
    code    VARCHAR(50) NOT NULL,

    CONSTRAINT pk_user_meal PRIMARY KEY (id),
    CONSTRAINT fk_user_meal_on_user FOREIGN KEY (user_id)
        REFERENCES "user" (id) ON DELETE CASCADE,
    CONSTRAINT fk_user_meal_on_meal FOREIGN KEY (meal_id)
        REFERENCES meal (id) ON DELETE CASCADE,
    CONSTRAINT unique_user_meal UNIQUE (user_id, meal_id)
);

-- Prevent Overbooking
CREATE OR REPLACE FUNCTION check_seat_availability()
RETURNS TRIGGER AS $$
DECLARE
available_seats INT;
BEGIN
    -- Locking to prevent race conditions
SELECT seats
INTO available_seats
FROM restaurant r
         JOIN meal m ON r.id = m.restaurant_id
WHERE m.id = NEW.meal_id
    FOR UPDATE;

IF (SELECT COUNT(*) FROM user_meal um
                             JOIN meal m ON um.meal_id = m.id
    WHERE um.meal_id = NEW.meal_id) >= available_seats
    THEN
        RAISE EXCEPTION 'No available seats for this meal';
END IF;
RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Prevent Multiple Meals at the same time per user
CREATE OR REPLACE FUNCTION check_user_meal_conflict()
RETURNS TRIGGER AS $$
DECLARE
new_meal_start TIMESTAMP;
    new_meal_end TIMESTAMP;
BEGIN
    -- Get the start time of the new meal
SELECT date INTO new_meal_start FROM meal WHERE id = NEW.meal_id;
new_meal_end := new_meal_start + INTERVAL '30 minutes';

    -- Check for overlapping meals
    IF EXISTS (
        SELECT 1
        FROM user_meal um
        JOIN meal m ON um.meal_id = m.id
        WHERE um.user_id = NEW.user_id
        AND (
            (m.date, m.date + INTERVAL '30 minutes')
            OVERLAPS
            (new_meal_start, new_meal_end)
        )
    ) THEN
        RAISE EXCEPTION 'User cannot have multiple overlapping meals';
END IF;

RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- Generate code for user_meal
CREATE OR REPLACE FUNCTION generate_user_meal_code()
RETURNS TRIGGER AS $$
BEGIN
    -- deterministic hash based on user_id and meal_id
    NEW.code := 'CUM-' || substr(md5(NEW.user_id::text || NEW.meal_id::text), 1, 8);
RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Triggers
CREATE TRIGGER trigger_generate_code
    BEFORE INSERT ON user_meal
    FOR EACH ROW
    EXECUTE FUNCTION generate_user_meal_code();

CREATE TRIGGER trigger_check_user_meal_conflict
    BEFORE INSERT ON user_meal
    FOR EACH ROW
    EXECUTE FUNCTION check_user_meal_conflict();

CREATE TRIGGER trigger_check_seats
    BEFORE INSERT ON user_meal
    FOR EACH ROW
    EXECUTE FUNCTION check_seat_availability();

-- Indexes for performance
CREATE INDEX idx_meal_restaurant ON meal(restaurant_id);
CREATE INDEX idx_user_meal_user ON user_meal(user_id);
CREATE INDEX idx_user_meal_meal ON user_meal(meal_id);
CREATE INDEX idx_user_meal_user_meal ON user_meal(user_id, meal_id);
